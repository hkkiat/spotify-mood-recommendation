// spotifyAuth.js
// require('dotenv').config({ path: '../spotify.env' });

const fetch = require('node-fetch');
const SpotifyWebApi = require('spotify-web-api-node');
// const { MongoClient } = require('mongodb');

// Set up the Spotify API client
const spotifyApi = new SpotifyWebApi({
  clientId: process.env.SPOTIFY_CLIENT_ID,
  clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
  redirectUri: process.env.REDIRECT_URI, 

});

async function authorize(_, { code }, { db }) {
  const data = await spotifyApi.authorizationCodeGrant(code);
  const { access_token, refresh_token, expires_in } = data.body;

  // Set the access token on the API object to use it in later calls
  spotifyApi.setAccessToken(access_token);

  const me = await spotifyApi.getMe();
  const userId = me.body.id;
  const expires_at = new Date(new Date().getTime() + expires_in * 1000);
  console.log(userId, access_token, refresh_token, expires_at)

  await saveUserTokens(null, {userId, accessToken: access_token, refreshToken: refresh_token, expiresAt: expires_at}, {db});

  return {
    userId,
    accessToken: access_token,
    refreshToken: refresh_token,
    expiresAt: expires_at,
  };
}

async function saveUserTokens(_, {userId, accessToken, refreshToken, expiresAt}, {db}) {
  console.log(accessToken)
  console.log(refreshToken)
  console.log(expiresAt)
  await db.collection('spotifyUser').updateOne(
    { userId },
    { $set: { accessToken, refreshToken, expiresAt } },
    { upsert: true }
  );
}

async function refreshAccessToken(_, { userId }, { db }) {
  // Retrieve the user's current refreshToken from the database
  const user = await db.collection('spotifyUser').findOne({ userId: userId });
  if (!user) {
    throw new Error('User not found');
  }

  // Set the credentials to be able to refresh the token
  spotifyApi.setRefreshToken(user.refreshToken);

  try {
    // Refresh the token
    const data = await spotifyApi.refreshAccessToken();
    const { access_token, expires_in } = data.body;

    // Calculate the new expiration date
    const expires_at = new Date(new Date().getTime() + expires_in * 1000);

    // Use the existing saveUserTokens function to save the new tokens
    await saveUserTokens(null, { userId, accessToken: access_token, refreshToken: user.refreshToken, expires_at }, { db });

    return access_token;
    // return {
    //   accessToken: access_token,
    //   expiresAt: expires_at,
    // };
  } catch (error) {
    console.error(`Error refreshing access token for user ${userId}:`, error);
    throw new Error('Failed to refresh Spotify access token');
  }
}

async function getUserAccessToken(_, {userId}, { db }) {
  const userRecord = await db.collection('spotifyUser').findOne({ userId });
  
  if (!userRecord) {
    throw new Error(`User with ID ${userId} not found.`);
  }

  const { _, userId, accessToken, expiresAt, refreshToken } = userRecord;
  
  // Check if the access token has expired
  if (new Date() > new Date(expiresAt)) {
    // Access token has expired, refresh it
    return await refreshAccessToken(_, { userId }, { db });
  } else {
    // Access token is still valid
    return accessToken;
  }
}


// original authroize function
// async function authorize(_, { code }) {
//     const response = await fetch('https://accounts.spotify.com/api/token', {
//     method: 'POST',
//     headers: {
//       'Content-Type': 'application/x-www-form-urlencoded',
//       'Authorization': 'Basic ' + Buffer.from(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`).toString('base64'),
//     },
//     body: new URLSearchParams({
//       code,
//       redirect_uri: process.env.REDIRECT_URI,
//       grant_type: 'authorization_code',
//     }),
//   });

//   const data = await response.json();
  
//   if (!response.ok) {
//     throw new Error(`Spotify authorization failed: ${data.error}`);
//   }

//   return {
//     accessToken: data.access_token,
//     refreshToken: data.refresh_token,
//     expiresIn: data.expires_in,
//   };
// }

// // Directly after your authorize function definition
// async function testAuthorize() {
//     try {
//         const authResponse = await authorize('AQBLIA3xbpy5CqPRryGOBfhUocbC9gFvoFecFZpeNs_biIwTCPu0XqarVAw5L68lEiA_w1PIAc1mmhwUx67rExuTrq1NM5QV4WB7lFf3UBnCfm3Zddd8cQboTbhz_alYabxOMXQ0uOVQmMCoLfCKOuaDiuzoQELw6Q7iBPRrhs0NOwvwX0jU39mzxx--KMgBlo6sJA');
//         console.log(authResponse);
//     } catch (error) {
//         console.error(error);
//     }
//   }
  
//   testAuthorize(); // Remember to replace 'your_authorization_code_here' with a real code
  



// original refreshaccesstoken
// async function refreshAccessToken(_, { refreshToken }, { db }) {
//   const response = await fetch('https://accounts.spotify.com/api/token', {
//     method: 'POST',
//     headers: {
//       'Content-Type': 'application/x-www-form-urlencoded',
//       'Authorization': 'Basic ' + Buffer.from(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`).toString('base64'),
//     },
//     body: new URLSearchParams({
//       refresh_token: refreshToken,
//       grant_type: 'refresh_token',
//     }),
//   });

//   const data = await response.json();
  
//   if (!response.ok) {
//     throw new Error(`Spotify token refresh failed: ${data.error}`);
//   }

//   return {
//     accessToken: data.access_token,
//     expiresIn: data.expires_in,
//   };
// }

// async function testRefreshAccessToken() {
//     const refreshToken = 'AQD8UVJmGHTB4Uw7TWTpfIsNUaN7TYeYMgY_vB98x-5EON63aGHP12ePpzmf5SosdTPx1dINOejtNrDKmlu5ng0i4IL1geAMqWL879_sZ26NV0qpbQp9sCOhmF9NgHU_Sw0'; // Replace this with your actual refresh token
//     try {
//         const refreshedTokens = await refreshAccessToken(refreshToken);
//         console.log('Refreshed tokens:', refreshedTokens);
//     } catch (error) {
//         console.error('Error refreshing access token:', error);
//     }
// }

// testRefreshAccessToken();

// async function saveUserTokens(userId, accessToken, refreshToken, expiresAt) {
//     // const db = getDb();
//     await db.collection('spotify').updateOne(
//       { userId },
//       { $set: { accessToken, refreshToken, expiresAt } },
//       { upsert: true }
//     );
//   }
  
//   async function getUserTokens(userId) {
//     // const db = getDb();
//     return await db.collection('spotify').findOne({ userId });
//   }
  
//   async function updateUserTokens(userId, accessToken, expiresAt) {
//     const db = getDb();
//     await db.collection('spotify').updateOne(
//       { userId },
//       { $set: { accessToken, expiresAt } }
//     );
//   }


async function createPlaylistBasedOnFavorites(_, { userId, valence, danceability, energy }) {
    // Set the access token for the API
    const accessToken = await getUserAccessToken(userId);
    spotifyApi.setAccessToken(accessToken);
  
    // Fetch user's top artists
    const topArtistsResponse = await spotifyApi.getMyTopArtists({ limit: 50 });
    const artistIds = topArtistsResponse.body.items.map(artist => artist.id);
  
    let allTracks = [];
    for (const artistId of artistIds) {
      // For each artist, fetch their top tracks
      const topTracksResponse = await spotifyApi.getArtistTopTracks(artistId, 'US'); // Assuming 'US' market
      allTracks.push(...topTracksResponse.body.tracks.slice(0, 1)); // Taking only the top track for simplicity
    }
  
    // Assuming a simplistic filter function based on your criteria; you'll need to implement actual filtering
    const filteredTracks = allTracks.filter(track => true); // Placeholder; implement filtering based on track features
  
    // Create a new playlist
    const playlistResponse = await spotifyApi.createPlaylist(userId, 'Your New Playlist', { public: false });
    const playlistId = playlistResponse.body.id;
  
    // Add tracks to the new playlist
    const trackURIs = filteredTracks.map(track => track.uri);
    await spotifyApi.addTracksToPlaylist(playlistId, trackURIs);
  
    return {
      id: playlistId,
      name: 'Your New Playlist',
      tracks: filteredTracks.map(track => ({
        id: track.id,
        name: track.name,
        artists: track.artists.map(artist => ({
          id: artist.id,
          name: artist.name,
        })),
      })),
    };
  }


module.exports = {
  authorize,
  refreshAccessToken,
};
